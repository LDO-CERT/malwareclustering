import time
import zarr

import dask
import dask.array as da
import dask.dataframe as dd
import numpy as np
from dask.distributed import Client
from dask_cuda import LocalCUDACluster
import cupy as cp

CHUNKSIZE = 100000


def create_dummy_data_source(size=10000000, chunksize=10000):
    a = np.random.choice(a=[0, 1], size=(size, 1024))
    b = np.array(a, dtype=np.uint16)
    z = zarr.array(b, chunks=(chunksize, 1024))
    zarr.save("/home/dask/zarr_uint16_test.zarr", z)


ruzicka_shared_kernel = cp.RawKernel(
    r"""
    extern "C" __global__
    #define TILE_WIDTH 32
    void shared_ruzicka(const unsigned short* x1, const unsigned short* x2, float* y, int width, int height) {
        __shared__ unsigned short x1s[TILE_WIDTH][TILE_WIDTH];
        __shared__ unsigned short x2s[TILE_WIDTH];

        // int bx = blockIdx.x; 
        int by = blockIdx.y;
        int tx = threadIdx.x; int ty = threadIdx.y;

        int row = by * TILE_WIDTH + ty;
        // int col = bx + TILE_WIDTH + tx;

        int idx = 0;
        unsigned short tmp = 0;
        float maxab = 0.0;
        float minab = 0.0;

        for (int m = 0; m < 1024/TILE_WIDTH; ++m){
            idx = row * width + m * TILE_WIDTH + tx;
            if (idx < width * height){
                x1s[ty][tx] = x1[idx];
                x2s[tx] = x2[m*TILE_WIDTH + tx];
                __syncthreads();
                for (int k=0; k < TILE_WIDTH; ++k){
                    tmp = x1s[ty][k] * (1023 - (m*TILE_WIDTH+k));
                    if(x2s[k] > tmp){
                        maxab += x2s[k];
                        minab += tmp;
                    }else{
                        minab += x2s[k];
                       maxab += tmp;
                    }
                }
                __syncthreads();
            }
        }
        y[row] = minab / maxab;
    }
""",
    "shared_ruzicka",
)


ruzicka_kernel = cp.RawKernel(
    r"""
    extern "C" __global__
    void my_ruzicka(const unsigned short* x1, const unsigned short* x2, float* y, int width, int height) {
        int col = threadIdx.x + blockIdx.x * blockDim.x; 
        int row = threadIdx.y + blockIdx.y * blockDim.y; 
        if(row < height && col < width){
            float maxab = 0.0;
            float minab = 0.0;
            unsigned short tmp = 0;
            for(int k = 0; k < width; k++){
                tmp = x1[row * width + k] * (1023 - k);
                if(x2[k] > tmp){
                    maxab += x2[k];
                    minab += tmp;
                }else{
                    minab += x2[k];
                    maxab += tmp;
                }
            }
            y[row] = minab / maxab;
        }
    }
""",
    "my_ruzicka",
)


def ruzicka_retval(a, b):
    pd_size = len(a)
    y = cp.zeros(CHUNKSIZE, dtype=cp.float32).reshape(1, CHUNKSIZE)
    ruzicka_kernel((32, (pd_size + 31) // 32), (32, 32), (a, b, y, 1024, pd_size))
    return y

def ruzicka_shared_retval(a, b):
    pd_size = len(a)
    y = cp.zeros(CHUNKSIZE, dtype=cp.float32).reshape(1, CHUNKSIZE)
    ruzicka_shared_kernel((32, (pd_size + 31) // 32), (32, 32), (a, b, y, 1024, pd_size))
    return y


def ruzicka_vec(vector_old, vector_new):
    vector_old_cp = cp.array(vector_old) * cp.arange(1023, -1, -1, dtype=cp.uint16)
    min_up = cp.minimum(vector_old_cp, vector_new)
    max_down = cp.maximum(vector_old_cp, vector_new)
    numerator = cp.sum(min_up, axis=1)
    denominator = cp.sum(max_down, axis=1)
    return cp.asnumpy(cp.divide(numerator, denominator))


def ruzicka_mat(matrix_a, vector_new):
    matrix_a *= cp.arange(1023, -1, -1, dtype=cp.uint16)
    min_up = cp.minimum(cp.array(matrix_a), vector_new)
    max_down = cp.maximum(cp.array(matrix_a), vector_new)
    numerator = cp.sum(min_up, axis=1)
    denominator = cp.sum(max_down, axis=1)
    return cp.asnumpy(cp.divide(numerator, denominator))


if __name__ == "__main__":
    cluster = LocalCUDACluster()
    client = Client(cluster)
    # GENERATE ONE RANDOM SAMPLE TO IDENTIFY
    vector_new = cp.array(cp.random.choice([1, 1], 1024), dtype=cp.uint16) * cp.arange(
        1023, -1, -1, dtype=cp.uint16
    )

    # DATABASE TO COMPARE
    # d_da = da.from_zarr("/home/dask/zarr_1M_uint16_test.zarr", chunks=(CHUNKSIZE, 1024))                    # 1M
    # d_da = da.from_zarr('/home/dask/zarr_uint16_test.zarr', chunks=(CHUNKSIZE,1024))                      # 10M
    d_da = da.from_zarr('/home/dask/zarr50M_uint16_100k_chunks_test.zarr', chunks=(CHUNKSIZE,1024))       # 50M
    # d_da = da.from_zarr('/home/dask/zarr100M_uint16_100k_chunks_test.zarr', chunks=(CHUNKSIZE,1024))      # 100M



    dask_raw = dask_shared_raw = dask_cupy = cupy_raw = dask_apply = False
    dask_raw = dask_shared_raw = dask_cupy = True

    if dask_raw:
        # 1 DASK ARRAY WITH RAW KERNEL
        start = time.time()
        res = d_da.map_blocks(
            lambda df: ruzicka_retval(cp.array(df), vector_new), dtype=cp.float32
        ).compute()
        print("dask_raw:", time.time() - start)
        print(res, res.shape)

    if dask_shared_raw:
        # 1 DASK ARRAY WITH RAW KERNEL
        start = time.time()
        res = d_da.map_blocks(
            lambda df: ruzicka_shared_retval(cp.array(df), vector_new), dtype=cp.float32
        ).compute()
        print("dask_shared_raw:", time.time() - start)
        print(res, res.shape)        

    if dask_cupy:
        # 2.1 DASK DATAFRAME WITH CUPY
        start = time.time()
        d_dd = dd.from_dask_array(d_da)
        res = d_dd.map_partitions(
            lambda df: ruzicka_mat(cp.array(df), vector_new),
            meta=("result", cp.float32),
        ).compute()
        print("dask_df_cupy:", time.time() - start)
        print(res)

        #        start = time.time()
        #        res = d_da.map_blocks(
        #            lambda df: ruzicka_mat(cp.array(df), vector_new), dtype=cp.float32
        #        ).compute()
        #        print("dask_da_cupy:", time.time() - start)
        #        print(res)

    if cupy_raw:
        # 3 CUPY
        start = time.time()
        y = cp.zeros(len(d_da), dtype=cp.float32)
        ruzicka_kernel(
            ((len(d_da) + 31) // 32, (len(d_da) + 31) // 32),
            (32, 32),
            (cp.array(d_da), vector_new, y, 1024, len(d_da)),
        )
        print("cupy_raw:", time.time() - start)
        #      print(y, len(y))

    if dask_apply:
        # 4 DASK ARRAY WITH apply_along_axis
        start = time.time()
        res = da.apply_along_axis(
            lambda df: ruzicka_vec(df, vector_new), 1, d_da
        ).compute()
        print("dask_apply:", time.time() - start)
        #     print(res, y)

    client.close()

