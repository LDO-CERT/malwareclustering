import numpy as np
import timeit
import re
import numexpr as ne

vector_list = ["A22gA5BA35QA17gACA3QA7gA9IAAgEIA3wA3gCAAME@EACRHAQAAQBACIRAADQAIA3wAQEE}rm@QfpT}/Mp-.n?",
               "A64IA13CA5RA13wAABA5EAECA5EA4CEgEAABGCAAgAyAABolBCA3WA4GADkBOA?QQgCIECmth.n?"]

_base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz@}]^+-*/?,._"
_bin2base64 = {"{:06b}".format(
    i): base64char for i, base64char in enumerate(_base64chars)}
_base642bin = {v: k for k, v in _bin2base64.items()}

_n_vector_ranks_only = np.arange(1023, -1, -1, dtype=np.int32)

# from stackoverflow
_base642bin_array = np.zeros((128,), dtype=np.uint8)
for i in range(len(_base64chars)):
    _base642bin_array[ord(_base64chars[i])] = i


def n_decompress2(compressed_vector):
    # encode is for Python 3: str -> bytes
    decompressed_b64 = "".join(_decompress_get(compressed_vector)).encode()
    # byte string into the underlying numeric data
    decompressed_b64 = np.fromstring(decompressed_b64, dtype=np.uint8)
    # conversion done by numpy indexing rather than dictionary lookup
    vectorized = _base642bin_array[decompressed_b64]
    # convert to a 2D array of 1s and 0s
    as_binary = np.unpackbits(vectorized[:, np.newaxis], axis=1)
    # remove the two digits you don't care about (always 0) from binary array
    as_binary = as_binary[:, 2:]
    # reshape to 1D (and chop off two at the end)
    return as_binary.ravel()[:-2]


def test_numpy_v2(x=vector_list[0], y=vector_list[1]):
    if len(x) != 1024:
        x = n_decompress2(x)
    vector_a = _n_apply_weights(x)
    if len(y) != 1024:
        y = n_decompress2(y)
    vector_b = _n_apply_weights(y)
    maxPQ = np.sum(np.maximum(vector_a, vector_b))
    return np.sum(np.minimum(vector_a, vector_b))/maxPQ

# end from stackoverflow
def test_base(x=vector_list[0], y=vector_list[1]):
    from apiscout.ApiScout import ApiScout
    _apiscout = ApiScout()
    _apiscout.setBaseAddress(0)
    _apiscout.loadWinApi1024('data/winapi1024v1.txt')
    return _apiscout.matchVectors(x, y)

def _decompress_get(data):
    for match in re.finditer(r"(?P<char>.)((?P<count>\d+))?", data):
        if not match.group("count"):
            yield match.group("char")
        else:
            yield match.group("char") * int(match.group("count"))


def _n_apply_weights(vector):
    return np.multiply(vector, _n_vector_ranks_only)


def n_decompress(compressed_vector):
    decompressed_b64 = "".join(_decompress_get(compressed_vector))
    vectorized = "".join(_base642bin[c] for c in decompressed_b64)[:-2]
    as_binary = np.fromiter(vectorized, int)
    return as_binary


def test_numpy(x=vector_list[0], y=vector_list[1]):
    if len(x) != 1024:
        x = n_decompress(x)
    vector_a = _n_apply_weights(x)
    if len(y) != 1024:
        y = n_decompress(y)
    vector_b = _n_apply_weights(y)
    maxPQ = np.sum(np.maximum(vector_a, vector_b))
    return np.sum(np.minimum(vector_a, vector_b))/maxPQ


def test_numexpr(x=vector_list[0], y=vector_list[1]):
    if len(x) != 1024:
        x = n_decompress2(x)
    vector_a = _n_apply_weights(x)
    if len(y) != 1024:
        y = n_decompress2(y)
    vector_b = _n_apply_weights(y)
    vector_c = [[x for x in vector_a], [x for x in vector_b]]
    min_v = ne.evaluate("min(vector_c, axis=0)")
    max_v = ne.evaluate("max(vector_c, axis=0)")
    sum_min = ne.evaluate("sum(min_v)")
    sum_max = ne.evaluate("sum(max_v)")
    res = ne.evaluate("sum_min / sum_max")
    return res


def test_read(x=np.load('numpy_arrays/x.npy'), y=np.load('numpy_arrays/y.npy')):
    vector_a = _n_apply_weights(x)
    vector_b = _n_apply_weights(y)
    maxPQ = np.sum(np.maximum(vector_a, vector_b))
    return np.sum(np.minimum(vector_a, vector_b))/maxPQ


def test_read_pac(x=np.load('numpy_arrays/z.npy'), y=np.load('numpy_arrays/w.npy')):
    x = np.unpackbits(x)
    y = np.unpackbits(y)
    vector_a = _n_apply_weights(x)
    vector_b = _n_apply_weights(y)
    maxPQ = np.sum(np.maximum(vector_a, vector_b))
    return np.sum(np.minimum(vector_a, vector_b))/maxPQ


def test_read_comp(x=np.load('numpy_arrays/xc.npz'), y=np.load('numpy_arrays/yc.npz')):
    x = x['v']
    y = y['v']
    vector_a = _n_apply_weights(x)
    vector_b = _n_apply_weights(y)
    maxPQ = np.sum(np.maximum(vector_a, vector_b))
    return np.sum(np.minimum(vector_a, vector_b))/maxPQ


def test_cython_str(x=vector_list[0], y=vector_list[1]):
    from ruzicka import rereretrial
    return rereretrial(x, y)


def test_cython_pac(x=np.load('numpy_arrays/z.npy'), y=np.load('numpy_arrays/w.npy')):
    from ruzicka import reretrial
    x = np.unpackbits(x)
    y = np.unpackbits(y)
    return reretrial(x, y)


def test_cython2_unp(x=np.load('numpy_arrays/x.npy'), y=np.load('numpy_arrays/y.npy')):
    from ruzicka import trial
    vector_a = _n_apply_weights(x)
    vector_b = _n_apply_weights(y)
    return trial(vector_a, vector_b)


def test_cython2_pac(x=np.load('numpy_arrays/z.npy'), y=np.load('numpy_arrays/w.npy')):
    from ruzicka import trial
    x = np.unpackbits(x)
    y = np.unpackbits(y)
    vector_a = _n_apply_weights(x)
    vector_b = _n_apply_weights(y)
    return trial(vector_a, vector_b)


def test_cython3_pac(x=np.load('numpy_arrays/z.npy'), y=np.load('numpy_arrays/w.npy')):
    from ruzicka import retrial
    x = np.unpackbits(x)
    y = np.unpackbits(y)
    vector_a = _n_apply_weights(x)
    vector_b = _n_apply_weights(y)
    return retrial(vector_a, vector_b)

import cppimport
cppimport.set_quiet(False)
cppimport.force_rebuild()
code = cppimport.imp("wrap7")


def test_pybind11(x=np.load('numpy_arrays/z.npy'), y=np.load('numpy_arrays/w.npy')):
    x = np.unpackbits(x)
    y = np.unpackbits(y)
    vector_a = _n_apply_weights(x)
    vector_b = _n_apply_weights(y)
    return code.ruzicka(vector_a, vector_b)

def calculate_n(num):
    #time_base = timeit.timeit("test_base()", number=num, setup="from __main__ import test_base")
    #time_test_numpy = timeit.timeit("test_numpy()", number=num, setup="from __main__ import test_numpy")
    time_test_numpy_v2 = timeit.timeit("test_numpy_v2()", number=num, setup="from __main__ import test_numpy_v2")
    #time_test_cython_str = timeit.timeit("test_cython_str()", number=num, setup="from __main__ import test_cython_str")
    #time_test_cython_pac = timeit.timeit("test_cython_pac()", number=num, setup="from __main__ import test_cython_pac")
    #time_test_numexpr = timeit.timeit("test_numexpr()", number=num, setup="from __main__ import test_numexpr")
    time_test_read = timeit.timeit("test_read()", number=num, setup="from __main__ import test_read")
    time_test_read_pac = timeit.timeit("test_read_pac()", number=num, setup="from __main__ import test_read_pac")
    #time_test_read_comp = timeit.timeit("test_read_comp()", number=num, setup="from __main__ import test_read_comp")
    time_test_cython2_unp = timeit.timeit("test_cython2_unp()", number=num, setup="from __main__ import test_cython2_unp")
    time_test_cython2_pac = timeit.timeit("test_cython2_pac()", number=num, setup="from __main__ import test_cython2_pac")
    #time_test_cython3_pac = timeit.timeit("test_cython3_pac()", number=num, setup="from __main__ import test_cython3_pac")
    time_test_pybind11 = timeit.timeit("test_pybind11()", number=num, setup="from __main__ import test_pybind11")

    #print('BASE:', time_base, test_base())
    #print('NUMPY:', time_test_numpy, test_numpy())
    print('NUMPY V2:', time_test_numpy_v2, test_numpy_v2())
    #print('NUMEXPR:', time_test_numexpr, test_numexpr())
    #print('CYTHON:', time_test_cython_pac, test_cython_pac())
    #print('CYTHON STR:', time_test_cython_str, test_cython_str())
    print('LOAD NUMPY:', time_test_read, test_read())
    print('LOAD NUMPY PACKED:', time_test_read_pac, test_read_pac())
    #print('LOAD NUMPY COMPRESSED:', time_test_read_comp, test_read_comp())
    print('CYTHON FOR UNP:', time_test_cython2_unp, test_cython2_unp())
    print('CYTHON FOR PAC:', time_test_cython2_pac, test_cython2_pac())
    #print('CYTHON PAR PAC:', time_test_cython3_pac, test_cython3_pac())
    print('PYBIND11:', time_test_pybind11, test_pybind11())


if __name__ == "__main__":
    calculate_n(100000)
