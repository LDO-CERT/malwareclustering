import asyncio
import asyncpg
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.python.client import device_lib
import time

"""
Sample of data returned from DB

>>> malpedia[0]
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x000\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x80@\x00\x00\x00\x00\x00\xc0\x00\x00\x10@\x80 \x00\x04\x00@\x111\xa4\x08\xb0~\x92\xf7\xf4\xcaX\xca^'

>>> type(malpedia[0])
<class 'bytes'>

>>> np.frombuffer(malpedia[0], dtype=np.uint8)
array([  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,  64,   0,   0,   0,  48,   0,   0,   0,   0,
         0,   0,  16,   0,   0,   0, 128,  64,   0,   0,   0,   0,   0,
       192,   0,   0,  16,  64, 128,  32,   0,   4,   0,  64,  17,  49,
       164,   8, 176, 126, 146, 247, 244, 202,  88, 202,  94], dtype=uint8)

>>> np.unpackbits(np.frombuffer(malpedia[0], dtype=np.uint8))
array([0, 0, 0, ..., 1, 1, 0], dtype=uint8)

Vector to be compared against others is composed by 1024 zeros and ones
"""


async def read_async():
    conn = await asyncpg.connect('postgresql://user:password@ip_addr/db_name')  
    rows = await conn.fetch('SELECT data FROM malware_clustering')
    return [x['data'] for x in rows]

if __name__ == "__main__":
    f_start = time.time()
    malpedia = asyncio.get_event_loop().run_until_complete(read_async())
    end = time.time()-f_start
    t_start = time.time()
    print("DB read time", end)

    gpu_names = [x.name for x in device_lib.list_local_devices() if x.device_type == 'GPU']
    _n_vector_ranks_only = np.arange(1023, -1, -1, dtype=np.int32)

    len_matrix = len(malpedia)
    arr_range = int(np.ceil(len_matrix/len(gpu_names)))

    #Retrieve first record as sample for comparison
    vector_b = np.unpackbits(np.frombuffer(malpedia[0], dtype=np.uint8))*_n_vector_ranks_only

    mirrored_strategy = tf.distribute.MirroredStrategy()

    for i, d in enumerate(gpu_names):
        with tf.device(d):
            start = i * arr_range
            end = min((i+1) * arr_range, len_matrix)
            mat_a = tf.constant(([np.unpackbits(np.frombuffer(x, dtype=np.uint8)) for x in malpedia[start:end]] * _n_vector_ranks_only), shape=[end-start, 1024])
            mat_b = tf.stack([tf.constant(vector_b)] * (end-start))
            min_a = tf.math.minimum(mat_a, mat_b)
            max_a = tf.math.maximum(mat_a, mat_b)
            numerator = tf.reduce_sum(min_a, 1)
            denominator = tf.reduce_sum(max_a, 1)
            ruz = tf.math.divide(numerator, denominator)

    print(ruz)
    end = time.time()-t_start
    print("GPU computation time", end)
    end = time.time()-f_start
    print("total time", end)
