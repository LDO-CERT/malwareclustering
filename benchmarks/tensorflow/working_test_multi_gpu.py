import asyncio
import asyncpg
import numpy as np
import pandas as pd
import os

from tensorflow.python.client import device_lib
import multiprocessing
from multiprocessing import Pool
import time

async def read_async():
    conn = await asyncpg.connect('postgresql://user:password@ip_address/database')  
    rows = await conn.fetch('SELECT data FROM malware_clustering')
    return [x['data'] for x in rows]


def ruz(id, Q):
    os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"
    os.environ["CUDA_VISIBLE_DEVICES"] = str(id)
    import tensorflow as tf
    import numpy as np
    (df, vector_b) = Q
    mat_a = tf.constant(([np.unpackbits(np.frombuffer(x, dtype=np.uint8)) for x in df] * np.arange(1023, -1, -1, dtype=np.int32)), shape=[len(df), 1024])
    mat_b = tf.stack([tf.constant(vector_b)] * len(df))
    min_up = tf.math.minimum(mat_a, mat_b)
    max_down = tf.math.maximum(mat_a, mat_b)
    numerator = tf.reduce_sum(min_up, 1)
    denominator = tf.reduce_sum(max_down, 1)
    return tf.math.divide(numerator, denominator)

if __name__ == "__main__":
    f_start = time.time()
    malpedia = asyncio.get_event_loop().run_until_complete(read_async())
    end = time.time()-f_start
    t_start = time.time()
    print("DB read time", end)

    len_matrix = len(malpedia)
    gpu_names = [x.name for x in device_lib.list_local_devices() if x.device_type == 'GPU']
    arr_range = int(np.ceil(len_matrix/len(gpu_names)))

    
    vector_b = np.unpackbits(np.frombuffer(malpedia[0], dtype=np.uint8))* np.arange(1023, -1, -1, dtype=np.int32)
    mytuple = [(i, (malpedia[i*arr_range:min((i+1)* arr_range, len_matrix)], vector_b)) for i in range(len(gpu_names))]
    
    multiprocessing.set_start_method('spawn', force=True)
    pool = Pool(len(gpu_names))
    results = pool.starmap(ruz, mytuple)
    pool.close()
    pool.join()
    for pp in results:
        print(pp)
    end = time.time()-t_start
    print("GPU computation time", end)
    end = time.time()-f_start
    print("total time", end)        
